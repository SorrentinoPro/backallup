#!/bin/bash

# Define color codes
GREEN=$(tput setaf 2)
GOLD=$(tput setaf 3)
RED=$(tput setaf 1)
NC=$(tput sgr0) # No Color

# Functions
check_mysql_credentials() {
    while getopts ":h:u:p:" opt; do
        case $opt in
        h) host="$OPTARG";;
        u) user="$OPTARG";;
        p) password="$OPTARG";;
        \?) echo "Invalid option: -$OPTARG"; exit 1;;
        esac
    done
    # Prompt the user to enter the MySQL credentials
    if [ -z "$host" ]; then
        read -p "Enter the MySQL host: " host
    else
        echo "host defined as $host" 
    fi
    if [ -z "$user" ]; then
        read -p "Enter the MySQL user: " user
    else
        echo "user defined as $user" 
    fi
    if [ -z "$password" ]; then
        read -s -p "Enter the MySQL password: " password
    else
        echo "password defined ******" 
    fi
    # Check if the credentials are correct
    echo "Verefying credentials, wait please ..."
    if mysql -h $host -u $user -p$password -e "SHOW DATABASES" &> /dev/null; then
        echo "${GREEN}MySQL credentials Matching!${NC}"
        return 0
    else
        echo "${RED}Invalid MySQL credentials.${NC}"
        host=""
        user=""
        password=""

        return 1
    fi
}


# Set the backup directory
BACKUP_DIR=/backallup/backups

# Check for dependencies
DEPENDENCIES=("tar" "jq" "ip" "hostname" "uname" "date")
for DEPENDENCY in "${DEPENDENCIES[@]}"; do
    if ! command -v "$DEPENDENCY" &>/dev/null; then
        echo "${RED}Error: $DEPENDENCY is not installed. Please install it and try again.${NC}"
        exit 1
    fi
done

# Define the help message
HELP_MESSAGE="
Usage: backallup [options]

Options:
    -h, --help      Display this help message
    -p, --profile   Specify the profile name
    -d, --domain    Specify the domain name
    -j, --json      Specify the custom JSON file
    -r, --restore   Restore a backup file
    -s, --server    Backup the entire server
    --skip-backups  Skip backing up the /backallup/backups folder
    -o              Restore to original path (only for restore command)
    -y              Yes to all prompts, at the end of any command

Examples:
    backallup myfile.txt
    backallup -p myprofile -d mydomain
    backallup -p myprofile -j custom.json
    backallup -s
    backallup -s --skip-backups
    backallup -r myfile.tar.gz
    backallup -r myfile.tar.gz -o

    backallup <any command> -y
"

# Get the command line arguments
options=$(getopt -o hp:d:j:r:s:oy --long help,profile:,domain:,json:,restore:,server,skipbks,yes -- "$@")
eval set -- "$options"

# Initialize variables
YAP=false
ORIGINAL_PATH=false
PROFILE_NAME=""
DOMAIN=""
CUSTOM_JSON_FILE=""
RESTORE_FILE=""
SERVER_BACKUP=false
SKIP_BACKUPS=false

while true; do
    case "$1" in
        -h|--help)
            echo "$HELP_MESSAGE"
            exit 0
            ;;
        -p|--profile)
            PROFILE_NAME="$2"
            shift 2
            ;;
        -d|--domain)
            DOMAIN="$2"
            shift 2
            ;;
        -j|--json)
            CUSTOM_JSON_FILE="$2"
            shift 2
            ;;
        -r|--restore)
            RESTORE_FILE="$2"
            shift 2
            ;;
        -s|--server)
            SERVER_BACKUP=true
            shift
            ;;
        --skipbks)
            SKIP_BACKUPS=true
            shift
            ;;
        -o)
            if [ -n "$RESTORE_FILE" ]; then
                ORIGINAL_PATH=true
            else
                echo "${RED}Error: -o option is only valid for restore command${NC}"
                exit 1
            fi
            shift
            ;;
        -y|--yes)
            YAP=true
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

# Set the hostname, IP address, OS name, and datetime
HOSTNAME=$(hostname)
IPADDRESS=$(dig +short $(hostname) | head -1)
if [ -z "$IPADDRESS" ]; then
    IPADDRESS=$(ip addr show | grep "inet " | head -1 | awk '{print $2}' | cut -d/ -f1)
fi
OSNAME=$(lsb_release -ds | xargs | tr ' ' '_')
DATETIME=$(date +%d-%m-%Y_%H-%M-%S)

# Implement the backallup commands
if $SERVER_BACKUP; then
    # Create the backup file
    FILENAME="${HOSTNAME}_${IPADDRESS}_${OSNAME}_${DATETIME}.tar.gz"
    BACKUP_PATH="${BACKUP_DIR}/${FILENAME}"

    # Create the backup
    if $SKIP_BACKUPS; then
        echo "Skipping ${BACKUP_DIR} from backup..."
        sudo tar -cvpzf "${BACKUP_PATH}" --exclude="${BACKUP_DIR}" --exclude="${BACKUP_PATH}" --one-file-system /
        echo "${GREEN}Full Backup, without ${BACKUP_DIR} created in: ${BACKUP_PATH}${NC}"
    else
        sudo tar -cvpzf "${BACKUP_PATH}" --exclude="${BACKUP_PATH}" --one-file-system /
        echo "${GREEN}Full Backup created in: ${BACKUP_PATH}${NC}"
    fi

    # Output the backup file name to the terminal
    echo "You will find it here: ${GOLD}${BACKUP_DIR}/${HOSTNAME}_${IPADDRESS}_${OSNAME}_${DATETIME}.tar.gz${NC}"

elif [ -n "$1" ]; then
    # Get the file or directory name
    FILE_OR_DIRECTORY=$1

 # Get the basename of the file or directory
    FILE_OR_DIRECTORY=$(basename "$FILE_OR_DIRECTORY")

    # Create the backup file
    if ! tar -cvpzf "${BACKUP_DIR}/${FILE_OR_DIRECTORY}_${DATETIME}.tar.gz" "$1"; then
        echo "${RED}Error: Failed to create backup file.${NC}"
        exit 1
    fi

    # Output the backup file name to the terminal
    echo "${GREEN}Backup file created: ${BACKUP_DIR}/${FILE_OR_DIRECTORY}_${DATETIME}.tar.gz${NC}"

elif [ -n "$PROFILE_NAME" ]; then
    # Get the profile configuration
    PROFILE_CONFIG=$(jq -r ".${PROFILE_NAME}" /backallup/profiles/allback2struct.json)

    if [ -n "$DOMAIN" ]; then
        # Create the backup file
        if ! tar -czf "${BACKUP_DIR}/${PROFILE_NAME}_${DOMAIN}_${DATETIME}.tar.gz" "${PROFILE_CONFIG}"; then
            echo "${RED}Error: Failed to create backup file.${NC}"
            exit 1
        fi

        # Output the backup file name to the terminal
        echo "${GREEN}Backup file created: ${BACKUP_DIR}/${PROFILE_NAME}_${DOMAIN}_${DATETIME}.tar.gz${NC}"
    else
        # Create the backup file
        if ! tar -czf "${BACKUP_DIR}/${PROFILE_NAME}_${DATETIME}.tar.gz" "${PROFILE_CONFIG}"; then
            echo "${RED}Error: Failed to create backup file.${NC}"
            exit 1
        fi

        # Output the backup file name to the terminal
        echo "${GREEN}Backup file created: ${BACKUP_DIR}/${PROFILE_NAME}_${DATETIME}.tar.gz${NC}"
    fi

elif [ -n "$RESTORE_FILE" ]; then
    # Restore the backup
    if [ ! -f "$RESTORE_FILE" ]; then
        echo "${RED}Error: Restore file not found.${NC}"
        exit 1
    else
        # Create a temporary directory to extract the files to
        TMP_DIR=$(mktemp -d)
        if ! tar -xvpzf "$RESTORE_FILE" -C "$TMP_DIR" > /dev/null; then
            echo "${RED}Error: Failed to restore backup file.${NC}"
            exit 1
        else
            # Ensure Original path right to action
            if [ "$YAP" != "true" ]; then
                if [ "$ORIGINAL_PATH" = "true" ]; then
                    while true; do
                        echo "${RED}WARNING!${NC} - you selected restore to original path (-o) this option will potentially overwrite existing files with the same name in the target directory."
                        read -p "${GOLD}Do you want to continue? (y/n): ${NC}" response
                        case $response in
                            y) break;;
                            n) echo "${GOLD}Exiting...${NC}"; exit 1;;
                            *) echo "${RED}Invalid response.${NC}";;
                        esac
                    done
                fi
            fi
            # Get the name of the directory
            json_file="$TMP_DIR/back2back.json"
            mysql_folder="$TMP_DIR/mysql"
            for dir in $(find "$TMP_DIR" -maxdepth 1 -type d -o -type f); do
                if [ "$dir" != "$TMP_DIR" -a "$dir" != "$mysql_folder" ]; then
                    # Construct the original path
                    new_path=${dir/${TMP_DIR}/}
                    # Check if a back2back.json file exists next to the directory
                    if [ "$dir" = "$json_file" ]; then
                        # Follow the structure in the back2back.json file to perform extra tasks
                        echo "${GREEN}Found $new_path Following structure >> ${NC}"
                        # Use jq to parse the JSON file and extract the values
                        domains=$(jq -r '.domains2goback | keys[]' "$json_file")
                        echo "Initializing restoration databases ..."
                        for domain in $domains; do
                            host=$(jq -r ".domains2goback.\"$domain\".mysql2goback.host" "$json_file")
                            user=$(jq -r ".domains2goback.\"$domain\".mysql2goback.user" "$json_file")
                            password=$(jq -r ".domains2goback.\"$domain\".mysql2goback.password" "$json_file")
                            db_name=$(jq -r ".domains2goback.\"$domain\".mysql2goback.database_name" "$json_file")
                            sql_file_name=$(jq -r ".domains2goback.\"$domain\".mysql2goback.sql_file" "$json_file")
                            
                            sql_file="$mysql_folder/$sql_file_name"
                            echo "Domain: $domain"
                            
                            if [ "$YAP" != "true" ]; then
                                while true; do
                                    read -p "${GOLD}Do you want to restore $sql_file_name? (y/n): ${NC}" response
                                    case $response in
                                        y|yes|Y|YES|Yes) echo "Trying Restoring..."; domainbk="true"; break;;
                                        n|no|N|NO|No) echo "${GOLD}Skipping ...${NC}"; domainbk="false"; break;;
                                        *) echo "${RED}Invalid response$.${NC}";;
                                    esac
                                done
                            else
                                domainbk="true"
                            fi
                            if [ "$domainbk" = "true" ]; then
                                echo "Checking associated $sql_file_name ..."
                                if [ -f  "$sql_file" ]; then
                                    echo "${GREEN}$sql_file_name Found!${NC}"
                                    echo "Checking $domain credential matches..."
                                    
                                    while true; do
                                        check_mysql_credentials -h $host -u $user -p $password
                                        if [ $? -eq 0 ]; then
                                            # echo "sql True"
                                            mysql_credentials="true"
                                            break
                                        else
                                            mysql_credentials="false"
                                            if [ "$YAP" != "true" ]; then
                                                read -p "${GOLD}Do you want to try again? (y/n):${NC}" response
                                                case $response in
                                                    y|yes|Y|YES|Yes) continue;;
                                                    n|no|N|NO|No) break;;
                                                    *) echo "${RED}Invalid response.${NC}";;
                                                esac
                                            elif [ "$YAP" = "true" ]; then
                                                echo "${RED}Failed MySQL credentials for $domain! -- Try Uploading $sql_file_name manually.${NC}"
                                                break
                                            else
                                                continue
                                            fi
                                        fi
                                    done
                                    #------ 
                                    if [ "$mysql_credentials" = "true" ]; then
                                        # Check if the database exists
                                        if mysql -u $user --password=$password -h $host -e "SHOW DATABASES LIKE '$db_name'" > /dev/null 2>&1; then
                                            # Database exists, proceed with the import/override/merge
                                            echo "${GOLD}Database $db_name exists.${NC}"
                                        
                                            # Check if the database is not empty
                                            count=$(mysql -u $user --password=$password -h $host -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '$db_name'" | tail -n 1 )
                                            if [ -n "$count" ]; then
                                                if [ $count -gt 0 ]; then
                                                    # Prompt the user to override/merge/cancel
                                                    read -p "${GOLD}Database $db_name is not empty. Do you want to:
                                                    (o) override it
                                                    (m) merge with the new data
                                                    (c) cancel the operation
                                                    ${NC}" response

                                                    case $response in
                                                    o)
                                                    # Override the database
                                                    echo "Overriding the database ..."
                                                    # Drop the existing tables
                                                    echo "Dropping existing tables..."
                                                    if mysql -u $user --password=$password -h $host $db_name -e "SET FOREIGN_KEY_CHECKS = 0; DROP TABLE IF EXISTS `information_schema`; SET FOREIGN_KEY_CHECKS = 1;" > /dev/null 2>&1; then
                                                        echo "${GREEN}Existing tables dropped successfully.${NC}"
                                                        echo " "
                                                        echo "Executing the SQL file to override ($db_name) ..."
                                                        # Execute the SQL file to override the database
                                                        if mysql -u $user --password=$password -h $host $db_name < $sql_file > /dev/null 2>&1; then
                                                        echo "${GREEN}Database overridden successfully.${NC}"
                                                        else
                                                        echo "Error overriding database: ${RED}Failed${NC}"
                                                        exit 1
                                                        fi
                                                    else
                                                        echo "Error dropping existing tables: ${RED}Failed${NC}"
                                                        exit 1
                                                    fi
                                                    ;;
                                                    m)
                                                    # Merge with the new data
                                                    echo "Merging with the new data ..."
                                                    # Execute the SQL file to merge with the new data
                                                    if mysql -u $user --password=$password -h $host $db_name < $sql_file > /dev/null 2>&1; then
                                                        echo "${GREEN}Database merged successfully.${NC}"
                                                    else
                                                        echo "Error merging database: ${RED}Failed${NC}"
                                                        exit 1
                                                    fi
                                                    ;;
                                                    c)
                                                    # Cancel the operation
                                                    echo "${GOLD}Operation cancelled.${NC}"
                                                    exit 1
                                                    ;;
                                                    *)
                                                    # Invalid input
                                                    echo "${RED}Invalid input. Please try again.${NC}"
                                                    ;;
                                                    esac
                                                else
                                                    # Database is empty, proceed with the import
                                                    echo "${GREEN}Database is empty${NC}, importing $sql_file_name data ..."
                                                    if mysql -u $user --password=$password -h $host $db_name < $sql_file > /dev/null 2>&1; then
                                                    echo "${GREEN}Database imported successfully.${NC}"
                                                    else
                                                    echo "Error importing database: ${RED}Failed${NC}"
                                                    exit 1
                                                    fi
                                                fi
                                            else
                                                echo "Error: unable to retrieve count. ${RED}Failed${NC}"
                                                exit 1
                                            fi
                                        else
                                            # Database does not exist, create a new one
                                            echo "${GREEN}Database $db_name does not exist${NC}, creating a new one..."
                                            if mysql -u $user --password=$password -h $host -e "CREATE DATABASE $db_name" > /dev/null 2>&1; then
                                                echo "${GREEN}Database created successfully.${NC}"
                                                # Import the new data
                                                echo "Importing new data..."
                                                if mysql -u $user --password=$password -h $host $db_name < $sql_file > /dev/null 2>&1; then
                                                    echo "${GREEN}Database imported successfully.${NC}"
                                                else
                                                    echo "Error importing database: ${RED}Failed${NC}"
                                                    exit 1
                                                fi
                                            else
                                                echo "Error creating database: ${ RED}Failed${NC}"
                                                exit 1
                                            fi
                                        fi
                                    fi
                                    #------                                  
                                fi
                                
                            else
                                echo "${GOLD}$domain database restoration skipped.${NC}"
                            fi
                        done
                    else
                        echo "Handling: $new_path"
                        # Ensure Original path right to action
                        if [ "$ORIGINAL_PATH" != "true" ]; then
                            # Construct the new path
                            new_path=$new_path"__BAU"
                             # Transfer folders and files
                            echo "Moving content to: $new_path"
                        else
                            # Move the directory to its respective location
                            echo "Merging content to $new_path ..."
                        fi
                        if [ -d $dir ]; then
                            rsync -a "$dir/" "$new_path/"
                        elif [ -f $dir ]; then
                            rsync -a "$dir" "$new_path"
                        fi
                        echo "${GREEN}=> Done.${NC}"
                    fi
                    echo "---------------------------------------------------"
                    echo " "
                fi
            done
            # Remove the temporary directory
            rm -rf "$TMP_DIR"
        fi
        echo "${GREEN}Backup file restored successfully.${NC}"
    fi
fi

