#!/bin/bash

# Define color codes
GREEN=$(tput setaf 2)
RED=$(tput setaf 1)
NC=$(tput sgr0) # No Color

# Functions
check_mysql_credentials() {
    while getopts ":h:u:p:" opt; do
        case $opt in
        h) host="$OPTARG";;
        u) user="$OPTARG";;
        p) password="$OPTARG";;
        \?) echo "Invalid option: -$OPTARG"; exit 1;;
        esac
    done
    # Prompt the user to enter the MySQL credentials
    if [ -z "$host" ]; then
        read -p "Enter the MySQL host: " host
    else
        echo "host defined as $host" 
    fi
    if [ -z "$user" ]; then
        read -p "Enter the MySQL user: " user
    else
        echo "user defined as $user" 
    fi
    if [ -z "$password" ]; then
        read -s -p "Enter the MySQL password: " password
    else
        echo "password defined ******" 
    fi
    # Check if the credentials are correct
    echo "Verefying credentials, wait please ..."
    if mysql -h $host -u $user -p$password -e "SHOW DATABASES" &> /dev/null; then
        echo "${GREEN}MySQL credentials Matching!${NC}"
        return 0
    else
        echo "${RED}Invalid MySQL credentials.${NC}"
        host=""
        user=""
        password=""

        return 1
    fi
}


# Set the backup directory
BACKUP_DIR=/backallup/backups

# Check for dependencies
DEPENDENCIES=("tar" "jq" "ip" "hostname" "uname" "date")
for DEPENDENCY in "${DEPENDENCIES[@]}"; do
    if ! command -v "$DEPENDENCY" &>/dev/null; then
        echo "Error: $DEPENDENCY is not installed. Please install it and try again."
        exit 1
    fi
done

# Define the help message
HELP_MESSAGE="
Usage: backallup [options]

Options:
    -h, --help      Display this help message
    -p, --profile   Specify the profile name
    -d, --domain    Specify the domain name
    -j, --json      Specify the custom JSON file
    -r, --restore   Restore a backup file
    -s, --server    Backup the entire server
    --skip-backups  Skip backing up the /backallup/backups folder
    -o              Restore to original path (only for restore command)
    -y              Yes to all prompts, at the end of any command

Examples:
    backallup myfile.txt
    backallup -p myprofile -d mydomain
    backallup -p myprofile -j custom.json
    backallup -s
    backallup -s --skip-backups
    backallup -r myfile.tar.gz
    backallup -r myfile.tar.gz -o

    backallup <any command> -y
"

# Get the command line arguments
options=$(getopt -o hp:d:j:r:s:oy --long help,profile:,domain:,json:,restore:,server,skipbks,yes -- "$@")
eval set -- "$options"

# Initialize variables
YAP=false
ORIGINAL_PATH=false
PROFILE_NAME=""
DOMAIN=""
CUSTOM_JSON_FILE=""
RESTORE_FILE=""
SERVER_BACKUP=false
SKIP_BACKUPS=false

while true; do
    case "$1" in
        -h|--help)
            echo "$HELP_MESSAGE"
            exit 0
            ;;
        -p|--profile)
            PROFILE_NAME="$2"
            shift 2
            ;;
        -d|--domain)
            DOMAIN="$2"
            shift 2
            ;;
        -j|--json)
            CUSTOM_JSON_FILE="$2"
            shift 2
            ;;
        -r|--restore)
            RESTORE_FILE="$2"
            shift 2
            ;;
        -s|--server)
            SERVER_BACKUP=true
            shift
            ;;
        --skipbks)
            SKIP_BACKUPS=true
            shift
            ;;
        -o)
            if [ -n "$RESTORE_FILE" ]; then
                ORIGINAL_PATH=true
            else
                echo "Error: -o option is only valid for restore command"
                exit 1
            fi
            shift
            ;;
        -y|--yes)
            YAP=true
            shift
            ;;
        --)
            shift
            break
            ;;
    esac
done

# Set the hostname, IP address, OS name, and datetime
HOSTNAME=$(hostname)
IPADDRESS=$(dig +short $(hostname) | head -1)
if [ -z "$IPADDRESS" ]; then
    IPADDRESS=$(ip addr show | grep "inet " | head -1 | awk '{print $2}' | cut -d/ -f1)
fi
OSNAME=$(lsb_release -ds | xargs | tr ' ' '_')
DATETIME=$(date +%d-%m-%Y_%H-%M-%S)

# Implement the backallup commands
if $SERVER_BACKUP; then
    # Create the backup file
    FILENAME="${HOSTNAME}_${IPADDRESS}_${OSNAME}_${DATETIME}.tar.gz"
    BACKUP_PATH="${BACKUP_DIR}/${FILENAME}"

    # Create the backup
    if $SKIP_BACKUPS; then
        echo "Skipping ${BACKUP_DIR} from backup..."
        sudo tar -cvpzf "${BACKUP_PATH}" --exclude="${BACKUP_DIR}" --exclude="${BACKUP_PATH}" --one-file-system /
        echo "Full Backup, without ${BACKUP_DIR} created in: ${BACKUP_PATH}"
    else
        sudo tar -cvpzf "${BACKUP_PATH}" --exclude="${BACKUP_PATH}" --one-file-system /
        echo "Full Backup created in: ${BACKUP_PATH}"
    fi

    # Output the backup file name to the terminal
    echo "You will find it here ${BACKUP_DIR}/${HOSTNAME}_${IPADDRESS}_${OSNAME}_${DATETIME}.tar.gz"

elif [ -n "$1" ]; then
    # Get the file or directory name
    FILE_OR_DIRECTORY=$1

 # Get the basename of the file or directory
    FILE_OR_DIRECTORY=$(basename "$FILE_OR_DIRECTORY")

    # Create the backup file
    if ! tar -cvpzf "${BACKUP_DIR}/${FILE_OR_DIRECTORY}_${DATETIME}.tar.gz" "$1"; then
        echo "Error: Failed to create backup file."
        exit 1
    fi

    # Output the backup file name to the terminal
    echo "Backup file created: ${BACKUP_DIR}/${FILE_OR_DIRECTORY}_${DATETIME}.tar.gz"

elif [ -n "$PROFILE_NAME" ]; then
    # Get the profile configuration
    PROFILE_CONFIG=$(jq -r ".${PROFILE_NAME}" /backallup/profiles/allback2struct.json)

    if [ -n "$DOMAIN" ]; then
        # Create the backup file
        if ! tar -czf "${BACKUP_DIR}/${PROFILE_NAME}_${DOMAIN}_${DATETIME}.tar.gz" "${PROFILE_CONFIG}"; then
            echo "Error: Failed to create backup file."
            exit 1
        fi

        # Output the backup file name to the terminal
        echo "Backup file created: ${BACKUP_DIR}/${PROFILE_NAME}_${DOMAIN}_${DATETIME}.tar.gz"
    else
        # Create the backup file
        if ! tar -czf "${BACKUP_DIR}/${PROFILE_NAME}_${DATETIME}.tar.gz" "${PROFILE_CONFIG}"; then
            echo "Error: Failed to create backup file."
            exit 1
        fi

        # Output the backup file name to the terminal
        echo "Backup file created: ${BACKUP_DIR}/${PROFILE_NAME}_${DATETIME}.tar.gz"
    fi

elif [ -n "$RESTORE_FILE" ]; then
    # Restore the backup
    if [ ! -f "$RESTORE_FILE" ]; then
        echo "Error: Restore file not found."
        exit 1
    else
        # Create a temporary directory to extract the files to
        TMP_DIR=$(mktemp -d)
        if ! tar -xvpzf "$RESTORE_FILE" -C "$TMP_DIR" > /dev/null; then
            echo "Error: Failed to restore backup file."
            exit 1
        else
            # Ensure Original path right to action
            if [ "$YAP" != "true" ]; then
                if [ "$ORIGINAL_PATH" = "true" ]; then
                    while true; do
                        echo "${RED}WARNING!${NC} - you selected restore to original path (-o) this option will potentially overwrite existing files with the same name in the target directory."
                        read -p "Do you want to continue? (yes/no): " response
                        case $response in
                            yes) break;;
                            no) echo "Exiting..."; exit 1;;
                            *) echo "Invalid response. Please enter yes or no.";;
                        esac
                    done
                fi
            fi
            # Get the name of the directory
            json_file="$TMP_DIR/back2back.json"
            mysql_folder="$TMP_DIR/mysql"
            for dir in $(find "$TMP_DIR" -maxdepth 1 -type d -o -type f); do
                if [ "$dir" != "$TMP_DIR" -a "$dir" != "$mysql_folder" ]; then
                    # Construct the original path
                    new_path=${dir/${TMP_DIR}/}
                    # Check if a back2back.json file exists next to the directory
                    if [ "$dir" = "$json_file" ]; then
                        # Follow the structure in the back2back.json file to perform extra tasks
                        echo "Found $new_path Following structure >> "
                        # Use jq to parse the JSON file and extract the values
                        domains=$(jq -r '.domains2goback | keys[]' "$json_file")
                        echo "Initializing restoration databases ..."
                        for domain in $domains; do
                            host=$(jq -r ".domains2goback.\"$domain\".mysql2goback.host" "$json_file")
                            user=$(jq -r ".domains2goback.\"$domain\".mysql2goback.user" "$json_file")
                            password=$(jq -r ".domains2goback.\"$domain\".mysql2goback.password" "$json_file")
                            db_name=$(jq -r ".domains2goback.\"$domain\".mysql2goback.database_name" "$json_file")
                            sql_file_name=$(jq -r ".domains2goback.\"$domain\".mysql2goback.sql_file" "$json_file")
                            
                            sql_file="$mysql_folder/$sql_file_name"
                            echo "Domain: $domain"
                            
                            if [ "$YAP" != "true" ]; then
                                while true; do
                                    read -p "Do you want to restore $sql_file_name? (yes/no): " response
                                    case $response in
                                        yes) echo "Restoring..."; domainbk="true"; break;;
                                        no) echo " Skipping..."; domainbk="false"; break;;
                                        *) echo "Invalid response. Please enter yes or no.";;
                                    esac
                                done
                            else
                                domainbk="true"
                            fi
                            if [ "$domainbk" = "true" ]; then
                                echo "Checking associated $sql_file_name exist..."
                                if [ -f  "$sql_file" ]; then
                                    echo "${GREEN}$sql_file_name Found!${NC}"
                                    echo "Checking $domain credentials match..."
                                    
                                    while true; do
                                        check_mysql_credentials -h $host -u $user -p $password
                                        if [ $? -eq 0 ]; then
                                            echo "sql True"
                                            mysql_credentials="true"
                                            break
                                        else
                                            mysql_credentials="false"
                                            if [ "$YAP" != "true" ]; then
                                                read -p "Do you want to try again? (yes/no): " response
                                                case $response in
                                                    yes) continue;;
                                                    no) break;;
                                                    *) echo "Invalid response. Please enter yes or no.";;
                                                esac
                                            elif [ "$YAP" = "true" ]; then
                                                echo "${RED}Failed MySQL credentials for $domain! -- Try Uploading $sql_file_name manually.${NC}"
                                                break
                                            else
                                                continue
                                            fi
                                        fi
                                    done
                                    
                                    if [ "$mysql_credentials" = "true" ]; then
                                        # Check if the database exists
                                        if mysql -h $host -u $user -p$password -e "SHOW DATABASES LIKE '$db_name'" | grep -q $db_name; then
                                            # Database exists, check if it's empty
                                            if mysql -h $host -u $user -p$password -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '$db_name'" | grep -q "0"; then
                                                # Database is empty, restore the SQL file
                                                mysql -h $host -u $user -p$password $db_name < $sql_file
                                            else
                                                # Database is not empty, prompt the user to override
                                                read -p "Database $db_name is not empty. Do you want to override it? (y/n) " -n 1 -r
                                                echo
                                                if [[ $REPLY =~ ^[Yy]$ ]]; then
                                                    # Drop the existing database and restore the SQL file
                                                    mysql -h $host -u $user -p$password -e "DROP DATABASE $db_name"
                                                    mysql -h $host -u $user -p$password -e "CREATE DATABASE $db_name"
                                                    mysql -h $host -u $user -p$password $db_name < $sql_file
                                                else
                                                    echo "Restore cancelled."
                                                fi
                                            fi
                                        else
                                            # Database does not exist, create it and restore the SQL file
                                            mysql -h $host -u $user -p$password -e "CREATE DATABASE $db_name"
                                            mysql -h $host -u $user -p$password $db_name < $sql_file
                                        fi
                                    fi
                                                                    
                                fi
                                
                            else
                                echo "$domain database restoration skipped."
                            fi
                        done
                    else
                        echo "Handling: $new_path"
                        # Ensure Original path right to action
                        if [ "$ORIGINAL_PATH" != "true" ]; then
                            # Construct the new path
                            new_path=$new_path"__BAU"
                        fi
                        # Transfer folders and files
                        echo "new location name = $new_path"
                        # Move the directory to its respective location
                        echo "moving $dir to $new_path"
                        # mv -i "$dir" "$new_path"
                        if [ -d $dir ]; then
                            rsync -a "$dir/" "$new_path/"
                        elif [ -f $dir ]; then
                            rsync -a "$dir" "$new_path"
                        fi
                    fi
                    echo "---------------------------------------------------"
                    echo " "
                fi
            done
            # Remove the temporary directory
            rm -rf "$TMP_DIR"
        fi
        echo "Backup file restored successfully."
    fi
fi

